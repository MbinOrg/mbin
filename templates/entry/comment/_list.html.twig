{% if showNested is not defined %}
    {% if app.request.cookies.get(constant('App\\Controller\\User\\ThemeSettingsController::ENTRY_COMMENTS_VIEW')) is same as constant('App\\Controller\\User\\ThemeSettingsController::CHAT') %}
        {% set showNested = false %}
    {% else %}
        {% set showNested = true %}
    {% endif %}
{% endif %}
<section class="comments entry-comments comments-tree"
         data-controller="subject-list"
         data-action="{{- app.request.cookies.get(constant('App\\Controller\\User\\ThemeSettingsController::KBIN_GENERAL_DYNAMIC_LISTS')) is same as 'true' ? 'notifications:EntryCommentCreatedNotification@window->subject-list#addComment' : 'notifications:EntryCommentCreatedNotification@window->subject-list#increaseCounter' -}}">
    {% for comment in comments %}
        {{ component('entry_comment', {
            comment: comment,
            showNested: showNested,
            dateAsUrl: dateAsUrl is defined ? dateAsUrl : false,
            showMagazineName: magazine is not defined or not magazine,
            showEntryTitle: entry is not defined or not entry
        }) }}
    {% endfor %}
    {% if(comments.haveToPaginate is defined and comments.haveToPaginate) %}
        {{ pagerfanta(comments, null, {'pageParameter':'[p]'}) }}
    {% endif %}
    {% if not comments|length %}
        <aside class="section section--muted">
            <p>{{ 'no_comments'|trans }}</p>
        </aside>
    {% elseif app.request.cookies.get(constant('App\\Controller\\User\\ThemeSettingsController::ENTRY_COMMENTS_VIEW')) is null or app.request.cookies.get(constant('App\\Controller\\User\\ThemeSettingsController::ENTRY_COMMENTS_VIEW')) is same as constant('App\\Controller\\User\\ThemeSettingsController::TREE') %}
        <div class="comment-line--2"></div>
        <div class="comment-line--3"></div>
        <div class="comment-line--4"></div>
        <div class="comment-line--5"></div>
        <div class="comment-line--6"></div>
        <div class="comment-line--7"></div>
        <div class="comment-line--8"></div>
        <div class="comment-line--9"></div>
    {% endif %}
</section>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const COMMENTS_TREE_CLASS = 'comments-tree';
    const COMMENT_ELEMENT = 'blockquote';
    const COMMENT_LEVEL_CLASS_REGEXP = /comment-level--(\d+)/;
    const HIDE_NESTED_CLASS = 'hide-nested';
    const COLLAPSED_COMMENT_CLASS = 'collapsed-tree';
    const HIDDEN_DIV_CLASS_LIST = (level) => `section comment ${COLLAPSED_COMMENT_CLASS} comment-level--${level}`;
    const COLLAPSE_INDICATOR = 'comment-collapse-indicator';

    const commentTree = document.querySelector(`.${COMMENTS_TREE_CLASS}`);
    commentTree.addEventListener('mouseup', collapseCommentTree);
    commentTree.addEventListener('touchend', collapseCommentTree);

    function collapseCommentTree(e) {
        const comment = e.target.closest(COMMENT_ELEMENT);
        const isTextSelected = window.getSelection().toString().length !== 0;

        // Don't collapse if user is just trying to select some text
        if (isTextSelected) {
            return;
        }

        // Don't collapse if user is just clicking links / buttons
        const blackListedElements = ['a', 'button']
        const whiteListedClass = COLLAPSE_INDICATOR;
        if (blackListedElements.includes(e.target.tagName.toLowerCase()) && !e.target.classList.contains(whiteListedClass)) {
            return;
        }

        // Don't interact if it's a collapse banner
        if (e.target.classList.contains(COLLAPSED_COMMENT_CLASS)) {
            return;
        }

        const isHideAction = !comment.classList.contains(HIDE_NESTED_CLASS);
        const levelMatch = comment.className.match(COMMENT_LEVEL_CLASS_REGEXP);
        const level = levelMatch ? parseInt(levelMatch[1], 10) : 1;

        let nextSibling = comment.nextElementSibling;
        // If we're expanding the tree again, skip the "x comments collapsed..." sibling element
        if (!isHideAction) { nextSibling = nextSibling.nextElementSibling; }

        let updateCount = 0;
        let lastComment;

        while (nextSibling) {
            const nextSiblingLevelMatch = nextSibling.className.match(COMMENT_LEVEL_CLASS_REGEXP);
            const isComment = !nextSibling.classList.contains(COLLAPSED_COMMENT_CLASS);

            // If next comment is a no longer a child (next comment <= comment clicked), we're done
            if (!nextSiblingLevelMatch || parseInt(nextSiblingLevelMatch[1], 10) <= level) {
                lastComment = nextSibling;
                break;
            }

            // If we're expanding the tree and we see another "x comments collapsed..." (nested tree in nested tree)
            // just delete it and continue expanding
            
            // TODO #284: Add functionality to preserve nested comment trees in nested comments trees instead
            // https://codeberg.org/Kbin/kbin-core/issues/284
            if (!isHideAction && !isComment) {
                nextSibling.previousElementSibling.classList.toggle(HIDE_NESTED_CLASS);
                const thisElement = nextSibling;
                nextSibling = nextSibling.nextElementSibling;
                thisElement.remove();
            } else {
                nextSibling.style.display = isHideAction ? 'none' : 'grid';
                nextSibling = nextSibling.nextElementSibling;
                isComment && updateCount++;
            }
        }

        comment.classList.toggle(HIDE_NESTED_CLASS);
        comment.querySelector(`.${COLLAPSE_INDICATOR}`).innerHTML = isHideAction ? '+' : '-'

        // If nothing hidden / shown, don't add a banner on the bottom
        if (updateCount < 1) { return; }
        

        if (isHideAction) {
            const hiddenDiv = document.createElement(COMMENT_ELEMENT);
            hiddenDiv.classList = HIDDEN_DIV_CLASS_LIST(level);
            hiddenDiv.innerText = `${updateCount} comments collapsed...`;
            comment.insertAdjacentElement('afterend', hiddenDiv);
        } else {
            comment.nextElementSibling.remove();
        }
    }
});
</script>